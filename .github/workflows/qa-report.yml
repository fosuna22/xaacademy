name: QA Report (manual - JSON simple)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch a ejecutar'
        required: true
        default: 'main'
      tag:
        description: 'Tag/grep para las pruebas (opcional, ej: @login)'
        required: false
        default: ''

jobs:
  cypress-and-report:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: |
          npm ci
          # Reporte JSON por spec con Mochawesome (solo JSON, sin HTML)
          npm i -D mochawesome mochawesome-merge

      # Genera UN JSON por spec (no se pisan)
      - name: Run Cypress (mochawesome JSON)
        env:
          TEST_TAG: ${{ github.event.inputs.tag }}
        run: |
          EXTRA_ARGS=""
          if [ -n "$TEST_TAG" ]; then
            # AjustÃ¡ segÃºn tu estrategia (cypress-grep, spec, etc.)
            # EXTRA_ARGS="--env grepTags=$TEST_TAG"
            # EXTRA_ARGS="--spec cypress/e2e/${TEST_TAG}.cy.js"
            echo "Ejecutando con filtro: $TEST_TAG (ajustÃ¡ EXTRA_ARGS si corresponde)"
          fi

          npx cypress run \
            --reporter mochawesome \
            --reporter-options "overwrite=false,html=false,json=true,reportDir=cypress/reports" \
            $EXTRA_ARGS || true

      # MERGE: incluye TODOS los *.json en uno solo
      - name: Merge mochawesome JSONs
        run: |
          set -euo pipefail
          echo "Archivos en cypress/reports:"
          ls -la cypress/reports || true

          rm -f cypress/reports/_merged.json cypress/reports/mochawesome.json

          shopt -s nullglob
          FILES=(cypress/reports/*.json)
          shopt -u nullglob

          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No hay JSONs de mochawesome (Â¿fallÃ³ Cypress?)"
            exit 1
          fi

          echo "Mergeando:"
          printf ' - %s\n' "${FILES[@]}"

          npx mochawesome-merge "${FILES[@]}" > cypress/reports/_merged.json
          mv cypress/reports/_merged.json cypress/reports/mochawesome.json
          echo "OK -> cypress/reports/mochawesome.json"

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # POST JSON simple con totales y detalle de fallos (suite + caso + archivo + error)
      - name: POST to n8n (JSON simple con detalles de fallos)
        env:
          WEBHOOK_URL: "https://francoosunaafip.app.n8n.cloud/webhook/7851647c-e729-498e-a11a-190e03f20d81"
        run: |
          set -euo pipefail

          RESULTS_JSON="cypress/reports/mochawesome.json"
          [ -f "$RESULTS_JSON" ] || { echo "No existe $RESULTS_JSON"; exit 1; }

          echo "Stats (segÃºn .stats del merge):"
          jq '.stats | {tests, passes, failures, pending, skipped, duration}' "$RESULTS_JSON" || true

          # âœ… Conteo REAL robusto: contempla "state", "pass" y "fail"
          PASSED=$(jq '[ .. | objects 
            | select( has("state") or has("pass") or has("fail") )
            | select( (.state=="passed") or (.state=="pass") or (.pass==true) )
          ] | length' "$RESULTS_JSON")

          FAILED=$(jq '[ .. | objects 
            | select( has("state") or has("pass") or has("fail") )
            | select( (.state=="failed") or (.state=="fail") or (.fail==true) )
          ] | length' "$RESULTS_JSON")

          # DuraciÃ³n: .stats.duration o suma por test
          DURATION=$(jq '.stats.duration // ([ .. | objects | select(has("duration")) | .duration ] | add // 0)' "$RESULTS_JSON")

          # ðŸ”Ž Detalle de fallos: suite + caso + archivo + error
          # - suite: intentamos .parentTitle si existe; si no, derivamos de fullTitle quitando title al final.
          # - test: .title
          # - file: .file (si viene), o .fullFile
          # - error: mensaje de error si viene en .err.message / .err
          FAILS=$(jq -c '[ .. | objects
              | select( (has("state") or has("fail")) and ((.state=="failed") or (.state=="fail") or (.fail==true)) )
              | {
                  suite: (.parentTitle // (.fullTitle // "" | sub(" " + (.title//"") + "$"; ""))),
                  test:  (.title // ""),
                  file:  (.file // .fullFile // ""),
                  error: (.err.message // .err // "")
                }
            ]' "$RESULTS_JSON")

          echo "Conteo real â†’ passed=$PASSED failed=$FAILED durationMs=$DURATION"
          echo "Fallos detectados:"
          echo "$FAILS" | jq -r '.[] | "- " + (.suite // "") + " :: " + (.test // "")' || true

          # Armar payload JSON de forma segura con jq
          PAYLOAD=$(jq -n \
            --argjson passed   "$PASSED" \
            --argjson failed   "$FAILED" \
            --argjson duration "$DURATION" \
            --argjson failures "$FAILS" \
            '{passed:$passed, failed:$failed, durationMs:$duration, failures:$failures}')

          echo "POST â†’ $WEBHOOK_URL"
          echo "$PAYLOAD" | jq . || true

          curl -sS -f -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -w "\nHTTP_CODE=%{http_code}\n"
